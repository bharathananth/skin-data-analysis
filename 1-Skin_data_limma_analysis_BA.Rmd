---
title: "MicroArray Analysis with Limma"
author: "Marta del Olmo"
date: "1/21/2021"
output: html_document
---

```{r setup, include=FALSE}
# `include=FALSE` indicates that this chunk will be run but not shown on the final HTML doc
# `echo = FALSE` prevents printing of the R code, just prints output
# `eval=FALSE` does not give output, on the other hand, just the code chunk

# This sets the options that will be used in all chunks from this Rmd document
knitr::opts_chunk$set(echo = TRUE)

# Set working directory
setwd("~/Documents/WORK/POSTDOC/projects/skin-data-analysis")
```

```{r libraries, include=FALSE}
library(limma)
library(magrittr)
library(hgug4112a.db)
library(ggrepel)
library(ggforce)
library(statmod)
library(GO.db)
library(tibble)
library(massiR)
library(tidyr)
library(dplyr) #IDK why I have to load the packages in this chunk again
library(tidyr)
library(ggplot2)
```

**1. Reading and processing microarray files -> normalization, background correction, duplicate-averaging **

**2. Analysis at the level of tissues: design matrix, fits **

**3. Plotting results of (2) in either-or: number of rhythmic genes, amplitudes, phases, GO, KEGG **

**4. Differential rhythmicity analysis: expressed + rhythmic genes in both**

### **Choosing cutoffs**

```{r cutoffs}
fdr_cutoff <- 0.05
amp_cutoff <- log2(1 + 0.2) 
```

***

## **1. Reading and processing microarray files**
Read the file `raw_MA_files.RDS` inside `data/` if it already exists. If not, create this file from the raw data (`extra/Skin Data/raw data/`) and annotate the probes.

```{r read_image_microarray_files}
if (!file.exists("data/raw_MA_files.RDS")){
  ##--------------Read in image files-------------------------------------------------------##
  files <- list.files("/extra/Skin Data/raw data/", full.names = TRUE)
  m <- regexpr("(D|E)\\d+_P\\d+", files, perl = TRUE)
  names <- regmatches(files, m)
  images <- read.maimages(files = files, source = "agilent", green.only = TRUE, names = names, 
                          other.columns = "gIsWellAboveBG")
  
  ##--------annotation of probes------------------------------------------------------------##
  images$genes$Symbol <- mapIds(hgug4112a.db, images$genes$ProbeName, keytype = "PROBEID", column = "SYMBOL")
  images$genes$ENSEMBL <- mapIds(hgug4112a.db, images$genes$ProbeName, keytype = "PROBEID", column = "ENSEMBL")
  images$genes$EntrezID <- mapIds(hgug4112a.db, images$genes$ProbeName, keytype = "PROBEID", column = "ENTREZID")
  
  saveRDS(images, file = "data/raw_MA_files.RDS",compress = "gzip")
} else {
  images <- readRDS("data/raw_MA_files.RDS")
}
```

Microarray data has to be __background-corrected__ and then __normalized__. We use the `normexp` method for background correction (preferred when background intensities are not known) and `quantile` for normalization between the different arrays.

```{r backgroudCorrect_normalization, eval=FALSE}
if (!file.exists("visualize/data/rawdata.rds")){
  y <- limma::backgroundCorrect(images, method = "normexp") 
  y <- normalizeBetweenArrays(y, method = "quantile")
}
```

Now we can filter out:

1. Controls (needed for background correction)
2. Probes that are not annotated
3. Those lowly-expressed samples -> _Typically half of the total number of samples, but we could take half of the samples from each patient._ ***This can be revisited later on.*** (Tradeoff strictness-results)

And average probes that map to the same gene. Typically microarray experiments include the so called **probesets**, which are oligos that target the same transcripts and that are located at different places of the chip or even in different chips. Thus, we have to correct for this redundancy. We do this in `yave`.

```{r filtering_and_redundancy}
if (!file.exists("visualize/data/rawdata.rds")){ 
  Control <- y$genes$ControlType==1L #Control <- y$genes$ControlType==1 would also work
  NoID    <- is.na(y$genes$ENSEMBL)
  IsExpr  <- rowSums(y$other$gIsWellAboveBG>0) >= 77 
  
  y0 <- y[!Control & !NoID & IsExpr, ]  # Data (expressed, identified, not controls) with gene annotation
  y0$genes <- y0$genes[, c("ProbeName", "Symbol", "ENSEMBL", "EntrezID")] 
  
  yave <- avereps(y0, y0$genes[, "ENSEMBL"])  # Averaging probes mapping to the same gene
  rownames(yave$E) <- yave$genes$ProbeName
}
```

We can now save this processed file.
```{r save_processed}
if (!file.exists("visualize/data/rawdata.rds")){ 
  saveRDS(yave, file = "visualize/data/rawdata.rds")
} else {
  yave <- readRDS("visualize/data/rawdata.rds")
}
```

## **2. Analysis at the level of tissues**

The objective of this section is **to look for average population rhythms in a tissue.**

We first extract the sample details from the column names, i.e., we build a dataframe with the tissue, time and subject # of the sample. 

Note for me: `y0` is only defined when we are processing the data (so when the rawdata.rds file does NOT exist). That's why the next chunk appears inside an if(!file.exists()) statement. If the file already exists, I just load it and extract sample details. 

```{r sample_details}
if (!file.exists("visualize/data/rawdata.rds")){ 
  ##----------------------extracting sample details from column names ----------------------##
  experiment <- data.frame(tissue = character(), time = integer(), subject = character()) %>%
                {strcapture("(\\w)(\\d+)_(\\w+)", colnames(y0$E), ., perl = TRUE)}
  
  tissue  <- factor(experiment$tissue)
  time    <- experiment$time
  subject <- factor(experiment$subject)
  
  saveRDS(experiment, "visualize/data/experiment.rds")
} else{
  experiment <- readRDS("visualize/data/experiment.rds")
  
  tissue  <- factor(experiment$tissue)
  time    <- experiment$time
  subject <- factor(experiment$subject)
}
```

Now the key part comes: to **construct the multi-level design matrix** and **fit the data**.

### **2.1. Multi-level design matrix**

1. We first have to define the two frequency components, `inphase` and `outphase` of the times at which samples were taken (i.e. 8, 12, 16, 20, 24, 28, 32). *Note that we need the two $sin()$ and $cos()$ components because what we do is similar to a Fourier transform, to extract frequency info we need both.* ->  <span style="color: red;">READ</span>

```{r for_freq_info}
inphase  <- cos(2*pi*time/24)
outphase <- sin(2*pi*time/24) #~ to fourier, to extract freq. info
```

```{r plot_freq_info, echo=FALSE}
ggplot(data = data.frame(time=time, inphase=inphase, outphase=outphase) %>% gather (in_out, value, -time)) +
  geom_point(aes(time, value, color=in_out)) +
  geom_line(aes(time, value, color=in_out)) +
  geom_hline(aes(yintercept=0), linetype='dashed') +
  theme_bw()
```

2. Now we define how we will perform the hypothesis testing. We follow an ANOVA approach (good for balanced designs). Note that the results will depend on our hypothesis testing. For example:

  + `model.matrix(~ subject + tissue) %>% head()` -> I am saying that my $H_0$ is that there is no difference between subjects and p100_Dermis. My reference in this case is p100Dermis. Subject and tissue are independent *categorical variables* because htey are separated by $+$ and there are no $:$ signs that denote interaction of such variables
  + `model.matrix(~ 0 + subject + tissue + inphase + outphase)` -> subject, tissue and time are independent categorical variables. In this case, the 0 indicates that p100Dermis is not the reference. Thus, all samples are compared among themselves (we will see that I don't have anymore an `Intercept` column, but a `p100` column instead) 
  + `model.matrix(~ 0 + subject + tissue + tissue:inphase + tissue:outphase)` -> here, we have subject and tissue as independent variables, but the colon `:` means interaction between the variables. Thus, we are saying that the coefficients that we obtain for inphase/outphase should be different for each tissue. 
  + A number of variables could be added here, for example sex. But keep in mind that the more terms we have in the `model.matrix`, the worse the $p$ values will be

```{r design_matrix}
design <- model.matrix(~ 0 + subject + tissue + tissue:inphase + tissue:outphase)
```

### **2.2. Fitting the data**

To fit the data:

1. We first assign weights to the different arrays. Since each array could be considered an independent experiment, we want to weigh down an outlier that we might have missed after background correction or quantile normalization. It's similar to a quality control step.
2. We fit a linear model ($H_0$ of a linear model is that slopes=0) to our data (`yave`) with the design matrix that we have defined, and with the estimated weights. <span style="color: red;">I don't get it graphically</span> 
    + The fitted coefficents `fit$coef` from the model fit are just the mean log-expression for each treatment combination for each probe set. **Check [this](https://www.bioconductor.org/help/course-materials/2005/BioC2005/labs/lab01/estrogen/) tutorial**
3. We use an empirical Bayes method (standard step in limma userguide) to calculate $p$ values

```{r fit}
wts <- limma::arrayWeights(yave, model.matrix(~tissue + subject)) 
    # model.matrix: simpler model used as suggested in userguide. (avoid?)
fit <- limma::lmFit(yave, design)#, weights = wts) 
fit2 <- limma::eBayes(fit, trend = TRUE, robust = TRUE) 
```

4. We organize the tissue:inphase and tissue:outphase results from `fit2` (i.e., the coefficients) together with gene annotations and statistics results, not caring about subject or tissue differences at this point. $p$ values are adjusted for multiple testing by Benjamini Hochberg. -> <span style="color: red;">Where does it get the $F, p$ and adjusted $p$ values from?</span>

```{r results}
rhy_indices <- which(grepl("phase",colnames(design)))
if (!file.exists("visualize/data/results.rds")){ 
  results <- limma::topTable(fit2, coef = rhy_indices, number = Inf, sort.by = "none") %>% 
    set_colnames(gsub("\\.","_", colnames(.))) 
  saveRDS(results, file = "visualize/data/results.rds")
}
```

## **3. Plotting analysis at tissue level**
From the `inphase/outphase` fitting coefficients, we can determine amplitude and phase of the oscillation of the gene that annotates to that probe.

```{r results_organized}
results <- readRDS("visualize/data/results.rds")
results %<>% #results %<>% == results <- results %>%
  dplyr::mutate(A_D = sqrt(tissueD_inphase^2 + tissueD_outphase^2), #Amp = cos**2 + sin**2 (note the log2 values)
  A_E = sqrt(tissueE_inphase^2 + tissueE_outphase^2),
  phaseD = atan2(tissueD_outphase, tissueD_inphase)*12/pi, 
           #atan2 takes two arguments, y and x, atan just takes the angle
  phaseE = atan2(tissueE_outphase, tissueE_inphase)*12/pi)
```

### 3.1. Number of rhythmic genes somewhere (in **either or** tissue) depending on the adjusted $p$ value
Let's plot how many rhythmic genes we end up with (with the `amp_cutoff` that we chose), depending on the `adj_P_Val`. Note that we filter our `results` data frame by saying that we get that probe whose dermis_Amp (`A_D`) **or** epidermis_Amp (`A_E`)i s above the threshold. Our condition is **OR**, and not **BOTH**.

```{r plot_Noofgenes, warning=FALSE}
plot_Noofgenes <- ggplot(data = dplyr::filter(results, pmax(A_D, A_E) > amp_cutoff) %>% 
                           dplyr::mutate(len = length(adj_P_Val))) + 
        #pmax gives the maximum of each zipped pair of values A_D[i], A_E[i]
    stat_ecdf(aes(x = adj_P_Val, len=len, y = ..y..*len), geom = "step") +  
        #we don't want fraction of genes (default of ecdf) but number, that's why we *len
    coord_cartesian(xlim = c(0.001, 0.05), ylim = c(0,2000)) + theme_bw() +
    xlab("False discovery rate") + ylab("number of rhythmic genes") 

if (!file.exists("figures/Noofgenes.pdf")){ 
  plot_Noofgenes %T>% ggsave("figures/Noofgenes.pdf", .) 
  # T pipe works like %>% but it returns  the left-hand side instead of the right-hand
}

plot_Noofgenes
```


### **3.2. Comparison of amplitudes and phases in dermis vs. epidermis**

Let's now plot how the amplitudes in dermis correlate with amplitudes in epidermis, and same with phases. 

Again, we filter our data to end up with those genes whose amplitude is $>$ than the `amp_cutoff` and now also we are interested in those genes whose adjusted $p$ value is $<$ `fdr_cutoff`. Note that we are filtering again in an **either-or** way (either `A_D` or `A_E` $>$ cutoff). <span style="color: red;">But, if I end up with scenarios in which the amplitude in one tissue is $<$ than the cutoff (see `dplyr::filter(results, ProbeName %in% some_rhythm) %>% head`, row4), how come I don't see this point in the plot?</span> 

```{r plot_Amplitude_Phase_compare}
some_rhythm <- dplyr::filter(results, pmax(A_D, A_E) > amp_cutoff & adj_P_Val < fdr_cutoff) %$% ProbeName 

clock_genes <- c("PER1","PER2","PER3", "CRY1", "CRY2", "NR1D1", "NR1D2", "ARNTL", "ARNTL2", "CLOCK", 
                 "NPAS2","RORA","RORB","RORC", "CSNK1D", "CSNK1E", "DBP")

plot_Amplitude_compare <- ggplot(data = dplyr::filter(results, ProbeName %in% some_rhythm), 
                                 aes(x=2^A_D-1, y=2^A_E-1)) + #amps are in log2
  geom_point(aes(color=Symbol %in% clock_genes), size=1) + 
  geom_text_repel(aes(label=ifelse(Symbol %in% clock_genes, as.character(Symbol), "")), color="red", 
                  max.overlaps=Inf, box.padding = 0.5) + 
  scale_color_manual(values=c("black","red")) +
  theme_bw() + theme(aspect.ratio = 1, legend.position = "none") + coord_cartesian(xlim=c(0,1), ylim = c(0,1)) +
  xlab("Relative Amplitude -- Dermis") + ylab("Relative Amplitude -- Epidermis")

if (!file.exists("figures/Amplitude_compare.pdf")){ 
  plot_Amplitude_compare %>% ggsave("figures/Amplitude_compare.pdf", .) 
} 

plot_Amplitude_compare

plot_Phase_compare <- ggplot(data = dplyr::filter(results, ProbeName %in% some_rhythm), 
                             aes(x=phaseD, y=phaseE)) + 
  geom_point(aes(color=Symbol %in% clock_genes), size=1) + 
  geom_text_repel(aes(label=ifelse(Symbol %in% clock_genes, as.character(Symbol), "")), color="red", 
                  max.overlaps=Inf, box.padding = 0.5) + 
  scale_color_manual(values=c("black","red")) +
  theme_bw() + theme(aspect.ratio = 1, legend.position = "none") + geom_abline(slope = 1, alpha=0.2) + 
  scale_x_continuous(breaks = seq(-12,12,by = 6)) +
  scale_y_continuous(breaks = seq(-12,12,by = 6)) + 
  xlab("Phase -- Dermis") + ylab("Phase -- Epidermis")

if (!file.exists("figures/Phase_compare.pdf")){ 
  plot_Phase_compare %>% ggsave("figures/Phase_compare.pdf", .) 
} 

plot_Phase_compare
```

### **3.3. GO and KEGG analyses of genes that are rhythmic somewhere (either-or)**

GO analysis of genes that are rhythmic in dermis or epidermis (not making distinction) -> amp $>$ `amp_cutoff` (either-or), fdr $<$ `fdr_cutoff`

```{r, GO_somewhere}
g <- goana(yave[yave$genes$ProbeName %in% some_rhythm,]$genes$EntrezID, universe = yave$genes$EntrezID) 
  #universe is the 'background' universe for the analysis, if none provided, then all EntrezID will be used
topGO(g, n=20, truncate.term = "42") # super significant terms have p values in the order of 10e-8
```

KEGG pathway analysis of genes that are rhythmic somewhere (no distinction)  -> amp $>$ `amp_cutoff` (either-or), fdr $<$ `fdr_cutoff`

```{r, KEGG_somewhere}
k <- kegga(yave[yave$genes$ProbeName %in% some_rhythm,]$genes$EntrezID, universe = yave$genes$EntrezID)
topKEGG(k, n=20, truncate.path = "42")
```

## **4. Working only with rhythmic genes in Dermis/Epidermis -- Differential rhythmicity analysis**
We are only going to work with the rhythmic genes we got from `some_rhythm` (genes whose expression was $>$ `amp_cutoff` and whose adjusted $p$ value was $<$ `fdr_cutoff`).

Knowing these rhythmic genes (in our data set), we go to our `yave` and `fit` matrices and select these -> Thus we are going to end with the expression levels (at the different tested time points) + fits of rhythmic genes.

```{r rhythmic_genes}
yrhy    <- yave[yave$genes$ProbeName %in% some_rhythm, ] #expression levels of rhythmic genes
fit_rhy <- fit[yave$genes$ProbeName %in% some_rhythm, ] #fits of those rhythmic genes
```

From [this](https://www.bioconductor.org/help/course-materials/2005/BioC2005/labs/lab01/estrogen/): The idea now is to use contrasts to make comparison of interest. Contrasts are linear combinations of parameters from the linear model fit, that allow the testing of these linear combinations (we have to formulate the hypothesis inside the `makeContrasts` function). In our case, we will estimate three contrasts (so our contrasts matrix will have two columns). The first contrast is the `inphase` component (differences between dermis and epidermis), the second contrast is the `outphase` component (differences between dermis and epidermis). In other words, our hypothesis to be tested is whether `inphase_dermis=inphase_epidermis` and `outphase_dermis=outphase_epidermis` (rhythms in dermis = rhythms in epidermis).

```{r contrasts}
colnames_proper <- gsub(":", "_", colnames(design))
contrast1 <- makeContrasts(tissueD_inphase - tissueE_inphase, tissueD_outphase - tissueE_outphase, 
                           levels = colnames_proper) #####?
rownames(contrast1) <- colnames(design)
```

Now we have to extract the linear model fits for the contrasts (from [this](https://www.bioconductor.org/help/course-materials/2005/BioC2005/labs/lab01/estrogen/) tutorial) and after we have the `lm_fit`, we calculate $p$ values with eBayes. We will end up with a matrix like `fit`, but this time our columns in `coefficients` will be our contrasts. 

```{r fits_contrasts}
fit_rhy2 <- contrasts.fit(fit = fit_rhy, contrasts = contrast1)
fit_rhy2 <- eBayes(fit_rhy2, trend = TRUE, robust = TRUE)
```

We then organize fit coefficients together with gene annotations and statistics results with `topTable`. $p$ values are adjusted for multiple testing by Benjamini Hochberg. -> <span style="color: red;">Same as before: where does it get the $F, p$ and adjusted $p$ values from?</span>

1. `results2`: contains the fit coefficients, gene anotations and statistics ($p$ value and adjusted $p$ value) of our comparison of inphase/outphase of dermis vs. epidermis. We have tested the hypothesis `inphase_dermis=inphase_epidermis` and `outphase_dermis='outphase_epidermis`. In other words, our $H_0$ was that there are no differences between the rhythmic genes in dermis vs. epidermis. We are getting statistics to these hypotheses.

    + In those genes where adjusted $p$ value < `fdr_cutoff`, we can reject the null hypothesis and say that there are differences between <span style="color: red;">rhythmic (or just expressed?)</span> genes in dermis vs. epidermis. This filtering is what we do on the next step (2)

2. `diff_rhythm`: we filter the `results2` to see which probes have an adjusted $p$ value $<$ `fdr_cutoff` -> These genes will be differentially <span style="color: red;">rhythmic</span> in dermis vs. epidermis. 

3. `results_diff_rhythm`: we filter the `diff_rhythm` genes/probes in our `results` data frame (the one containing info about amplitude/phases of all expressed genes) and estimate the amplitude ratio `Aratio` and phase difference `ph_diff` between dermis and epidermis. 

    + Note that since `A_E` and `A_D` values are in log2, for the amplitude ratio we just have to substract them. <span style="color: red;">But I don't get the same value if I do $\frac{2^{A_E}-1} {2^{A_D}-1}$!!!</span>

```{r results_DR}
results2 <- topTable(fit_rhy2, number = Inf, sort.by = "none") %>%
  set_colnames(gsub("\\.","_", colnames(.)))

diff_rhythm <- dplyr::filter(results2, adj_P_Val < fdr_cutoff) %$% ProbeName

results_diff_rhythm <- results %>% dplyr::filter(ProbeName %in% diff_rhythm) %>%
  dplyr::mutate(Aratio = A_E-A_D, ph_diff = (phaseE-phaseD + 12) %% 24 - 12) # %%=mod -> determines remainder
```

### **4.1. Plot of amplitudes of differentially rhythmic genes **
Now we plot the amplitude of dermis vs. amplitude of epidermis, and highlight those genes whose rhythmicity is different in D from E in red. <span style="color: red;">Amplitudes plotted before were in log2!!!!</span>

```{r plot_Amplitude_compare_diffrhy}
plot_Amplitude_compare_diffrhy <- ggplot(dplyr::filter(results, ProbeName %in% some_rhythm)) + 
                                          # rhythm in either-or
  geom_rect(xmin = amp_cutoff, xmax=1, ymin=0, ymax = amp_cutoff, alpha=0.1, fill="grey90") + 
  geom_rect(xmin = 0, xmax=amp_cutoff, ymin=amp_cutoff, ymax = 1, alpha=0.1, fill="grey90") + 
  geom_point(aes(x=2^A_D-1, y=2^A_E-1, 
                 color=factor(ProbeName %in% diff_rhythm, levels=c(TRUE, FALSE))), size=0.75) +
  theme_bw() + theme(aspect.ratio = 1, legend.position = "none") + scale_color_manual(values=c("red", "black")) + 
  xlab("Relative Amplitude -- Dermis") + ylab("Relative Amplitude -- Epidermis") + 
  coord_cartesian(xlim=c(0,1),ylim=c(0,1))

if (!file.exists("figures/Amplitude_compare_diffrhy.pdf")){ 
  plot_Amplitude_compare_diffrhy %>% ggsave("figures/Amplitude_compare_diffrhy.pdf", .) 
} 

plot_Amplitude_compare_diffrhy
```

### **4.2. Histograms of amplitude/phase differences between those DR genes in E vs D**

```{r plot_histograms_AmpPh_differences_DR}
plot_Histogram_amplitudes <- ggplot(results_diff_rhythm) + 
  geom_histogram(aes(x=Aratio),bins = 50, fill=NA, color="grey20") + 
  theme_bw() +
  xlab("Amplitude_Epidermis - Amplitude_Dermis")
plot_Histogram_amplitudes

plot_Histogram_phases <- ggplot(results_diff_rhythm) + 
  geom_histogram(aes(x=ph_diff),bins = 50, fill=NA, color="grey20") + 
  theme_bw() +
  xlab("Phase_Epidermis - Phase_Dermis") + coord_polar(start = pi/50+pi)
plot_Histogram_phases
```

### **4.3. Correlation Aratio vs. phase_difference of DR genes**

```{r plot_correlation_AmpPh_differences_DR}
plot_Amplitude_phase_corr <- ggplot(results_diff_rhythm) + 
  geom_point(aes(x=Aratio, y=ph_diff))
plot_Amplitude_phase_corr
```

### **4.4. Plot rhythms in D and E from DR genes**

To get the fitted values:

1. We get the coefficients from `inphase` and `outphase` columns from our `fit` (genes expressed either-or) (dimensions = 11578 x 4)
2. We multiply this matrix times the `design` matrix (transposed) (dimensions of transposed matrix = 4*154)
  + Remember that, in order to multiply matrices, columns of matrix $M_1$ must be equal to rows of matrix $M_2$
3. As a results of this matrix multiplication, the dimensions of my new matrix $M_3$ are: rows = rows $M_1$, columns = columns $M_2$ -> 11578 x 154. This means that for each gene, I have 154 measurements (11 patients * 7 time points * 2 tissues). In other words, for each gene I get the "fitted" timeseries for all patients in both tissues!! :)

```{r fitted_values}
fitted_values <- fit$coefficients[, rhy_indices] %*% t(design[, rhy_indices]) %>%
                 set_rownames(fit$genes$Symbol) %>%
                 set_colnames(colnames(yave$E))
```

Our aim is to plot the rhythm of the DR genes in epidermis vs. dermis.

1. We filter the `results_diff_rhythmic` such that we end with genes whose amp is $>$ the `amp_cutoff` in **both** tissues -> that's why we force the `min` of the pair of `(A_D, A_E)` values to be $>$ ``amp_cutoff`
2. We organize the data into `mean_data` by:
  + Taking `yave$E` (11578 x 154) and adding two columns, corresponding to `ProbeName` and `Symbol`
  + `gather` the data: leave ProbeName + Symbol and gather the info of patient+tissue (`junk`) and the expression `value`
  + `separate` the `junk` column to `tissuetime` + `subject`
  + `separate` `tissuetime` in `tissue` + `time`
  + Filter the DR genes
  + Calculate, for example, the mean of Dermis_08, Dermis_12, etc. of across all subjects, and then substract the original value - the `mean(value)`


```{r organize_fitted_data, warning=FALSE}
in_both_rhythm <- results_diff_rhythm %>% dplyr::filter(pmin(A_D, A_E) > amp_cutoff)

mean_data <- yave$E %>% transform(ProbeName = yave$genes$ProbeName, 
                     Symbol = yave$genes$Symbol) %>% as_tibble() %>%
                     #transform is the same as dplyr::mutate, just that works for matrices
                     #this matrix is 11578 (#genes) x 156 (#samples + col=ProbeName + col=Symbol)
         tidyr::gather(junk, value, -ProbeName, -Symbol) %>%
         tidyr::separate(junk, c("tissuetime","subject"), sep = "_", convert = TRUE) %>%
         tidyr::separate(tissuetime, c("tissue","time"), convert = TRUE, sep = 1) %>%
         dplyr::filter(ProbeName %in% diff_rhythm) %>%
         dplyr::group_by(ProbeName, Symbol, tissue, time) %>%
         dplyr::summarise(value = mean(value)) %>% 
            #value == mean value across all patients (mean of D08, D12, D16... across subjects)
         dplyr::mutate(value = value - mean(value))
```

Now we have the mean expression value (across subjects) of each gene, for each tissue and each time point. Let's plot the subject-mean rhythms.

```{r plot_rhythms}
page_no <- 8 #8 pages with n_pages 
             #(https://www.programmingwithr.com/how-to-make-your-facet-wrap-facet-grid-ggplots-span-across-multiple-pages-in-pdf/)

for (i in 1:page_no){
  p <- ggplot(mean_data) + 
    geom_rect(xmin=4,xmax=36,ymin=-amp_cutoff,ymax=amp_cutoff, fill="grey80", alpha=0.1) +
    geom_line(aes(x=time, y=value, group=tissue, color=tissue)) + 
    facet_wrap_paginate(~Symbol, ncol=8, nrow = 9, page=i) + theme_bw(base_size = 8) + 
    theme(aspect.ratio = 1, strip.text = element_text(size=6), legend.position = "top") 
  
  if (!file.exists(sprintf("figures/Diff_rhy_genes_%d.pdf", i))){ 
    p %>% ggsave(sprintf("figures/Diff_rhy_genes_%d.pdf", i),.,width = 7,height = 10) 
  } 
}
```







